# GridBuffer

广告模型训练需要用到大量的样本，在 `io` 模块需要快速地读取样本。因此样本的保存格式与读取性能对于模型训练非常重要。

GridBuffer 是一种专门为存储广告稀疏模型使用的数据而设计的格式。

GridBuffer 使用 `simd` 来加速压缩和 IO 操作。数据以列优先的方式存储。 提供类似于 `ndarray` 的接口。

## 为什么要设计一种新格式

简短的回答是：数据格式是数据存储和 IO 性能的核心部分，为了极致的效率和性能, 专门为广告模型样本设计一种
新格式是绝对值得的。

详细的答案涉及模型训练的一些关键环节:

1. 由于训练样本量大，我们需要高性能的格式来加速 IO，同时需要高压缩比来减少数据大小。即序列化和反序列化。
这对大型模型训练非常重要，因为如果 IO 不够快，很容易成为整个训练的瓶颈。

2. 样本通常按"行"构造，即每行数据中包含训练所需要的 `user` 或 `item` 的数据。但在训练时，样本会被组装
成固定的 `batch`，之后作为训练框架的输入进行训练。这个组装过程需要考虑多线程的处理，有很多处理逻辑, 也很耗时。

3. 每个模型的样本都有自己的过滤逻辑，即需要在所有的样本中按行挑选出属于当前模型的样本。这一步骤可以在准备特征
阶段完成，也可以在训练框架的 `io` 模块完成。如果在准备特征阶段完成，则需要将结果保存起来，会浪费存储, 如果是
在训练框架的 `io` 模块完成，则读取的数据就比较多, 浪费带宽。

4. 每个模型都有自己的训练特征，这意味着对于每一行，我们只选择一部分特征来输入模型, 即按列来过滤。 所以如果总
特征数量很大，训练需要的每个样本的特征数量可能只是一个小不分。我们需要读取整行来获取少量特征，这是一种浪费。

5. 我们通常有一组基础模型的特征，当我们想添加新特征时，我们经常需要根据键（如 `request_id` 
或 `user_id` 等）将新数据连接到基础特征。这个连接工作通常由 `hive` 完成，但当数据量大时，
`hive` 中的 `join` 操作通常很慢且消耗资源。因为我们需要全局地对基础特征和新特征进行 shuffle。

### 目前的解决方案

1. protobuf
2. flatbuffers
3. arrow
4. 自定义 `batch`格式
5. 使用 `bucket join` 的读时合并

下面详细介绍下每种格式的优缺点。

#### protobuf

#### flatbuffers

#### arrow

#### 自定义 `batch` 格式

#### 使用 `bucket join` 的读时合并

## GridBuffer 格式

可以看出，目前的一些解决方案总是会有一些限制，不能很好的解决模型训练中的所有问题。原因在于这些格式设计的出
发点都是通用的格式，解决的是更普遍的问题。而广告模型的样本有其独特的特点，如果不能利用上这些特点，就只能作
为通用格式来使用，从而总是存在一些限制。

### 广告模型样本的特点

以下几点是广告模型样本所独有的特点:
- 数据量大，需要高性能的读取，以及高压缩比来节省存储。(严格来说不算独有的特点，大部分数据都有这个特点)
- 样本大部分都是 `int` 类型, 且可能会有大量的重复。
- 训练时候样本会按 `batch` 进行构造。
- 样本会按行进行过滤，选择每个模型需要的样本。
- 样本也会按列进行过滤，选择每个模型需要的特征。
- 一条样本中只有一个 `user`, 但是可能会有多个 `item`.
- 需要根据 `user_id`, `item_id` 等进行 `join` 操作。
- 在产生样本时，需要构造一条完整的样本再进行序列化以及保存。不会中途修改。
- 在模型训练时为只读数据, 不会对其进行修改。

### GridBuffer 的设计

在广告模型样本的特点中，最值得关注的就是第二点，即大部分都是 `int` 类型, 且可能会有大量的重复。对于
这样的 `int` 类型存在一种比通用压缩更好更快的方式，即 `simd` 压缩。其压缩与解压速度都远远超过通用
的压缩，同时也能实现较高的压缩比。

`GridBuffer` 就是在 `simd` 基础上设计的一种格式。

#### 格式设计

`GridBuffer` 设计为一种类似于 `2` 维 `table` 的格式，其大小固定，`table` 的每一行可以包含多个 `cell`，每个
 `cell` 除了包含数据外，还可以包含一些 `meta` 信息, 如 `value` 的类型等。

#### 接口设计

接口设计主要考虑易用性，分为 `构造` 和 `读取` 两个部分。

##### 构造

`table` 大小必须在初始化时候指定，为了方便使用，支持各种灵活的方式添加数据，如按 `cell` 添加，按行添加等。

###### 指定大小

###### 添加数据

###### 完成

##### 读取

读取时的数据为只读数据，支持按不同的方式进行读取，如按 `cell` 读取，按行读取等。

#### 序列化

序列化格式为自定义的二进制格式。

考虑到同一列的数据是来自同一个特征，所以可以按列进行 `simd` 压缩。因此序列化按列进行 `simd` 压缩。然后将所有
列的数据拼接起来。同时需要在开始保存 `meta` 信息，用于之后的解压。

#### 反序列化

反序列化同样先按列进行 `simd` 解压，然后再合并到一起。

#### 底层实现

为了实现高性能的访问，我们需要尽可能的避免 `malloc` 以及内存拷贝。并且压缩是按列进行，我们需要尽可能的将同一列
的数据保存在连续的内存中。因此我们采取了 `meta` 信息和数据分开保存的方式。目前只支持 `u64` 类型和 `f32` 类型。

